#!/usr/bin/env python3

import os
import sys
import argparse
from concurrent.futures import ThreadPoolExecutor
from SigProfilerMatrixGenerator.scripts import SigProfilerMatrixGeneratorFunc as matGen
from SigProfilerExtractor import sigpro as sig

currentDirectory = os.getcwd()

def parse_arguments():
    """Parse arguments, validate and return the args"""

    parser = argparse.ArgumentParser(
        description='Compute mutational signatures.',
        formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('-o', '--output', default=currentDirectory,
                        help='Path to and name of output directory - Can be relative or full path')

    parser.add_argument('-i', '--vcfpath',
                        help='Path to directory containing vcf file(s) - Can be relative or full path')

    parser.add_argument('-g', '--genome', default='GRCh38',
                        help='Optional definition of genome, defaults to GRCh38')

    parser.add_argument('-p', '--project', metavar="<arg>",
                        help='Name of the project')

    parser.add_argument('-e', '--exome', default=False, action="store_true",
                        help='Set if input is from exome')

    parser.add_argument('-t', '--threads', default=-1, type=int,
                        help='Set number of threads, default will use all threads')

    # prints help message when 0 arguments are entered
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    parser_args = parser.parse_args()

    return parser_args

def extractSignatures(output,
                      vcfpath,
                      genome,
                      project,
                      sigClass='SBS',
                      sigContext='96',
                      exome=False,
                      threads=-1):
    """Extracts signatures from a matrix generated by SigProfilerMatrixGenerator"""

    sigType = sigClass + sigContext

    if exome:
        input_data = vcfpath+"/output/"+sigClass+"/"+project+"."+sigType+".exome"
    else:
        input_data = vcfpath+"/output/"+sigClass+"/"+project+"."+sigType+".all"

    sig.sigProfilerExtractor("matrix", output, input_data, reference_genome=genome, opportunity_genome = genome, context_type=sigType ,minimum_signatures=1, maximum_signatures=10, cpu=threads)

    from SigProfilerExtractor import decomposition as decomp
    signatures = output+"/"+sigType+"/Suggested_Solution/"+sigType+"_De-Novo_Solution/Signatures/"+sigType+"_De-Novo_Signatures.txt"
    activities = output+"/"+sigType+"/Suggested_Solution/"+sigType+"_De-Novo_Solution/Activities/"+sigType+"_De-Novo_Activities_refit.txt"
    samples = output+"/"+sigType+"/Samples.txt"

    #to get all cosmic signatures without filtering
    decomp.decompose(signatures, activities, samples, output, genome_build=genome, verbose=False, nnls_add_penalty=0.0, nnls_remove_penalty=0.0, initial_remove_penalty=0.0, de_novo_fit_penalty=0.02)

def main():
    # Parse and validate arguments
    args = parse_arguments()

    matrices = matGen.SigProfilerMatrixGeneratorFunc(args.project, args.genome, args.vcfpath, plot=True, exome=args.exome, bed_file=None, chrom_based=False, tsb_stat=False, seqInfo=False, cushion=100)

    num_tasks = 0
    sig_list = []

    try:
        if matrices['96'][args.project].sum() > 0:
            num_tasks = num_tasks + 1
            sig_list.append(('SBS', '96'))
        else:
            if os.path.exists(args.vcfpath+"/output/SBS"):
                for f in os.listdir(args.vcfpath+"/output/SBS"):
                    os.remove(os.path.join(args.vcfpath+"/output/SBS", f))
                os.rmdir(args.vcfpath+"/output/SBS")
    except:
        if os.path.exists(args.vcfpath+"/output/SBS"):
            for f in os.listdir(args.vcfpath+"/output/SBS"):
                os.remove(os.path.join(args.vcfpath+"/output/SBS", f))
            os.rmdir(args.vcfpath+"/output/SBS")

    try:
        if matrices['DINUC'][args.project].sum() > 0:
            num_tasks = num_tasks + 1
            sig_list.append(('DBS', '78'))
        else:
            if os.path.exists(args.vcfpath+"/output/DBS"):
                for f in os.listdir(args.vcfpath+"/output/DBS"):
                    os.remove(os.path.join(args.vcfpath+"/output/DBS", f))
                os.rmdir(args.vcfpath+"/output/DBS")
    except:
        if os.path.exists(args.vcfpath+"/output/DBS"):
            for f in os.listdir(args.vcfpath+"/output/DBS"):
                os.remove(os.path.join(args.vcfpath+"/output/DBS", f))
            os.rmdir(args.vcfpath+"/output/DBS")

    try:
        if matrices['ID'][args.project].sum() > 0:
            num_tasks = num_tasks + 1
            sig_list.append(('ID', '83'))
        else:
            if os.path.exists(args.vcfpath+"/output/ID"):
                for f in os.listdir(args.vcfpath+"/output/ID"):
                    os.remove(os.path.join(args.vcfpath+"/output/ID", f))
                os.rmdir(args.vcfpath+"/output/ID")
    except:
        if os.path.exists(args.vcfpath+"/output/ID"):
            for f in os.listdir(args.vcfpath+"/output/ID"):
                os.remove(os.path.join(args.vcfpath+"/output/ID", f))
            os.rmdir(args.vcfpath+"/output/ID")

    if num_tasks > 0:
        cpus_per_task = max(int(args.threads/num_tasks),1)
        with ThreadPoolExecutor(max_workers=3) as e:
            for sigClass, sigContext in sig_list:
                e.submit(extractSignatures, args.output, args.vcfpath, args.genome, args.project, sigClass, sigContext, args.exome, cpus_per_task)

if __name__ == '__main__':
    main()
